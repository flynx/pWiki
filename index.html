<!DOCTYPE html>
<html>
<head>
<title>pWiki</title>
</head>
<style>
</style>

<script src="ext-lib/jquery.js"></script>
<script src="wiki.js"></script>

<script>

var clear = () => {
	delete localStorage['wiki-data']
	delete localStorage['wiki-location']
}

var reload = () => {
	$('.dir').text('/' + Wiki.dir)

	$('.title').text(Wiki.title)

	// process text...
	var text = Wiki.text

	// expand macros...
	if($('.text').prop('contenteditable') != 'true'){
		text = text
			// Syntax:
			//		@<macro>( <args> )
			.replace(/@([a-zA-Z-_]+)\(([^)]*)\)/g, function(_, macro, args){
				args = $('<div>')
					.html(args)
					.text()
						.trim()
						.split(/\s+/g)

				//console.log('>>>>>', macro, args)

				if(macro == 'filter' && args.length == 1){
					console.log('FILTER:', args[0])
					// XXX
					return ''
				}

				if(macro == 'include' && args.length == 1){
					w = Object.create(Wiki)
					w.location = args[0]
					return w.text
				}

				if(macro == 'attr' 
						&& args.length == 1
						&& ['title', 'path', 'location', 'dir'].indexOf(args[0]) >= 0){
					return Wiki[args[0]]
				}

				return _
			})
			// html-like macro syntax...
			.replace(/\&lt;[a-zA-Z-_:]+.*?\/?\&gt;/g, function(t){
				var elem = $($('<div>').html(t).text())
				var macro = elem.prop('tagName').toLowerCase()

				var args = {}
				var a = elem.prop('attributes')

				for(var i=0; i<a.length; i++){
					args[a[i].name] = a[i].value
				}

				//console.log('>>>>>', macro, args) 

				if(macro == 'filter' && args.name != null){
					console.log('FILTER:', args.name)
					// XXX
					return ''
				}

				if(macro == 'include' && args.src != null){
					w = Object.create(Wiki)
					w.location = args.src
					return w.text
				}

				if(macro == 'attr' 
						&& args.name != null
						&& ['title', 'path', 'location', 'dir'].indexOf(args.name) >= 0){
					return Wiki[args.name]
				}

				return t
			})
	}

	$('.text').html(activateWikiWords(text))

	// XXX save...
	localStorage['wiki-data'] = JSON.stringify(Wiki.__wiki_data)
	localStorage['wiki-location'] = Wiki.location

	$('title').text(Wiki.location)
}

// XXX add history support...
var go = (path) => {
	history.pushState({
			wikipath: path
		}, 
		Wiki.title, 
		window.location)

	Wiki.location = path
	reload()
}

var clearWikiWords = elem => {
	// clear existing...
	elem.find('.WikiWord').each(function(){
			$(this).replaceWith(this.childNodes)})
	return elem
} 

var activateWikiWords = text => 
	text
		// set new...
		.replace(
			Wiki.__wiki_link__,
			'<a class="WikiWord" href="#" onclick="go($(this).text().replace(/^\\[|\\]$/g, \'\'))">$1</a>')


$(() => {
	$(window).on('popstate', function(evt){
		event.state 
			&& event.state.wikipath 
			&& go(event.state.wikipath)
	})

	// load stored data...
	Wiki.__wiki_data = localStorage['wiki-data'] ?
		JSON.parse(localStorage['wiki-data']) 
		: data
	Wiki.__wiki_data.__proto__ = BaseData

	Wiki.location = localStorage['wiki-location'] || Wiki.location


	reload()

	// XXX make this update on enter...
	$('.title')
		.on('blur', () => { 
			Wiki.title = $('.title').text() 
			reload()
		})

	// live update text...
	// XXX is this the right way to go for large documents???
	$('.text')
		.focus(() => {
			$('.text').prop('contenteditable', $('.text').prop('contenteditable') != 'true')
			reload()
		})
		.on('keyup', () => { 
			if($('.text').prop('contenteditable') == 'true'){
				Wiki.text = clearWikiWords($('.text').clone()).html() 
			}
		})
		// XXX do this live, but on a timeout after user input...
		// XXX need to place the cursor in the same position...
		.blur(() => { 
			$('.text').prop('contenteditable', false)
			reload() 
		})
})
</script>

<body>

<div class="dir"></div>
<hr>
<h1 class="title" contenteditable tabindex=0></h1>
<div class="text" tabindex=0></div>

</body>
</html>
<!-- vim:set sw=4 ts=4 : -->
